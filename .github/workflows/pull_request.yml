name: CI Workflow

on:
  pull_request:
    branches:
      - '**'

permissions:
  contents: read
  checks: write
  security-events: write

jobs:
  test:
    name: Run Tests with Coverage
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0 

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '9.0.x'

    - name: Restore dependencies
      run: dotnet restore

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: 'csharp'

    - name: Build solution
      id: build
      run: dotnet build --configuration Release --no-restore

    - name: Run tests, collect as TRX to support dorny test reporter
      run: dotnet test --configuration Release --no-build --verbosity normal --logger "trx;LogFileName=TestResults.trx"
      continue-on-error: true

    - name: Report Test Results
      uses: dorny/test-reporter@v1
      continue-on-error: true
      with:
        name: Test Results
        path: "**/TestResults.trx"
        reporter: dotnet-trx
        fail-on-error: 'true'

    - name: Install ReportGenerator
      run: dotnet tool install --global dotnet-reportgenerator-globaltool

    - name: Run tests, collect with XPlat Code Coverage to support CodeCov
      run: dotnet test --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --results-directory:TestResults
      continue-on-error: true

    - name: Generate Coverage Report
      run: reportgenerator -reports:TestResults/**/coverage.cobertura.xml -targetdir:TestResults/CoverageReport -reporttypes:"HtmlInline_AzurePipelines;Cobertura"

    - name: Upload coverage to CodeCov
      uses: codecov/codecov-action@v5
      with:
        files: ${{ github.workspace }}\TestResults\CoverageReport\Cobertura.xml
        fail_ci_if_error: false
        token: ${{ secrets.CODECOV_TOKEN }}

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      if: steps.build.outcome == 'success'

    - name: Extract version from .csproj
      id: get_version
      shell: pwsh
      run: |
        $version = (Select-String -Path src/Presentation/GameControllerForZwift.WPF/GameControllerForZwift.WPF.csproj -Pattern '<Version>(.*?)</Version>').Matches.Groups[1].Value
        echo "version=$version" >> $env:GITHUB_OUTPUT

    - name: Check if tag for version exists (only for main)
      if: github.event.pull_request.base.ref == 'main'
      id: check_tag
      shell: pwsh
      run: |
        $tagExists = git tag --list | Where-Object { $_ -eq "${{ steps.get_version.outputs.version }}" }
        if ($tagExists) {
          Write-Host "Tag already exists. ${version} is not a new app version."
          echo "tag_exists=true" >> $env:GITHUB_ENV
        } else {
          Write-Host "Tag does not exist. ${version} is a new app version."
          echo "tag_exists=false" >> $env:GITHUB_ENV

    - name: Report Check as Status
      if: github.event.pull_request.base.ref == 'main'
      uses: actions/github-script@v6
      with:
        script: |
          const { context, github } = require("@actions/github");
          const tagExists = process.env.tag_exists === 'true';
          
          const conclusion = tagExists ? 'failure' : 'success';
          const message = tagExists
            ? `Version ${version} already exists. Please update the version number.`
            : `This is a new app version (${version}).`;

          await github.rest.checks.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            name: "Tag Existence Check",
            head_sha: context.payload.pull_request.head.sha,
            status: "completed",
            conclusion: conclusion,
            output: {
              title: "Tag Existence Check",
              summary: message,
            },
          });